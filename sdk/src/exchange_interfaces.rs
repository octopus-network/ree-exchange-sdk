use crate::{CoinBalance, IntentionSet, Pubkey, TxRecord, Txid, Utxo};
use alloc::borrow::Cow;
use candid::CandidType;
use ic_stable_structures::{
    memory_manager::{MemoryId, MemoryManager, VirtualMemory},
    storable::Bound,
    BTreeMap, DefaultMemoryImpl, Storable,
};
use serde::{Deserialize, Serialize};

#[doc(hidden)]
pub type Memory = VirtualMemory<DefaultMemoryImpl>;
#[doc(hidden)]
pub type BlockStorage = BTreeMap<u32, NewBlockInfo, Memory>;
#[doc(hidden)]
pub type TransactionStorage = BTreeMap<(Txid, bool), TxRecord, Memory>;
#[doc(hidden)]
pub type PoolStorage<S> = BTreeMap<String, Pool<S>, Memory>;

#[doc(hidden)]
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct PoolBasic {
    pub name: String,
    pub address: String,
}

#[doc(hidden)]
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct PoolInfo {
    pub key: Pubkey,
    pub key_derivation_path: Vec<Vec<u8>>,
    pub name: String,
    pub address: String,
    pub nonce: u64,
    pub coin_reserved: Vec<CoinBalance>,
    pub btc_reserved: u64,
    pub utxos: Vec<Utxo>,
    pub attributes: String,
}

#[doc(hidden)]
pub type GetPoolListResponse = Vec<PoolBasic>;

#[doc(hidden)]
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct GetPoolInfoArgs {
    pub pool_address: String,
}

#[doc(hidden)]
pub type GetPoolInfoResponse = Option<PoolInfo>;

/// The parameters for the `action` function, i.e. the `#[ree_exchange_sdk::action]` function.
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct ExecuteTxArgs {
    pub psbt_hex: String,
    pub txid: Txid,
    pub intention_set: IntentionSet,
    pub intention_index: u32,
    pub zero_confirmed_tx_queue_length: u32,
}

impl ExecuteTxArgs {
    pub fn psbt(&self) -> Result<bitcoin::Psbt, String> {
        let raw = hex::decode(&self.psbt_hex).map_err(|_| "invalid psbt".to_string())?;
        bitcoin::Psbt::deserialize(raw.as_slice()).map_err(|_| "invalid psbt".to_string())
    }
}

/// The response for the `actions`.
pub type ExecuteTxResponse = Result<String, String>;

#[doc(hidden)]
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct RollbackTxArgs {
    pub txid: Txid,
}

#[doc(hidden)]
pub type RollbackTxResponse = Result<(), String>;

/// The parameters for the hook `on_block_received` and `on_block_processed`
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct NewBlockInfo {
    pub block_height: u32,
    pub block_hash: String,
    /// The block timestamp in seconds since the Unix epoch.
    pub block_timestamp: u64,
    pub confirmed_txids: Vec<Txid>,
}

#[doc(hidden)]
pub type NewBlockArgs = NewBlockInfo;

#[doc(hidden)]
pub type NewBlockResponse = Result<(), String>;

#[doc(hidden)]
impl Storable for NewBlockInfo {
    fn to_bytes(&self) -> Cow<[u8]> {
        let bytes = bincode::serialize(self).unwrap();
        Cow::Owned(bytes)
    }

    fn into_bytes(self) -> Vec<u8> {
        bincode::serialize(&self).unwrap()
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        bincode::deserialize(bytes.as_ref()).unwrap()
    }

    const BOUND: Bound = Bound::Unbounded;
}

/// The network enum defines the networks supported by the exchange.
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub enum Network {
    Bitcoin,
    Testnet4,
}

#[doc(hidden)]
pub fn ensure_access<P: Pools>() -> Result<(), String> {
    match P::network() {
        Network::Bitcoin => crate::orchestrator_interfaces::ensure_orchestrator(),
        Network::Testnet4 => crate::orchestrator_interfaces::ensure_testnet4_orchestrator(),
    }
}

/// The parameters for the hook `on_state_confirmed` and `on_state_finalized`
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct Block {
    pub height: u32,
    pub hash: String,
    pub timestamp: u64,
}

/// The metadata for the pool, which includes the key, name, and address.
/// Typically, the key and address should be generated by the IC chain-key.
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct Metadata {
    pub key: Pubkey,
    pub key_derivation_path: Vec<Vec<u8>>,
    pub name: String,
    pub address: String,
}

/// The essential information about the pool state.
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct StateInfo {
    pub nonce: u64,
    pub txid: Txid,
    pub coin_reserved: Vec<CoinBalance>,
    pub btc_reserved: u64,
    pub utxos: Vec<Utxo>,
    pub attributes: String,
}

/// User must implement the `StateView` trait for customized state to provide this information.
pub trait StateView {
    fn inspect_state(&self) -> StateInfo;
}

/// The concrete type stored in the IC stable memory.
/// The SDK will automatically manage the pool state `S`.
#[derive(CandidType, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]
pub struct Pool<S> {
    metadata: Metadata,
    states: Vec<S>,
}

impl Storable for Metadata {
    fn to_bytes(&self) -> Cow<[u8]> {
        let bytes = bincode::serialize(self).unwrap();
        Cow::Owned(bytes)
    }

    fn into_bytes(self) -> Vec<u8> {
        bincode::serialize(&self).unwrap()
    }

    fn from_bytes(bytes: Cow<[u8]>) -> Self {
        bincode::deserialize(bytes.as_ref()).unwrap()
    }

    const BOUND: Bound = Bound::Unbounded;
}

impl<S> Storable for Pool<S>
where
    S: Storable,
{
    const BOUND: Bound = Bound::Unbounded;

    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        let metadata_bytes = self.metadata.to_bytes();
        let metadata_bytes_len = metadata_bytes.as_ref().len();
        let mut bytes = vec![];
        bytes.extend_from_slice(&(metadata_bytes_len as u32).to_le_bytes());
        bytes.extend_from_slice(metadata_bytes.as_ref());
        bytes.extend_from_slice(&(self.states.len() as u32).to_le_bytes());
        for state in self.states.iter() {
            let state_bytes = state.to_bytes();
            let state_bytes_len = state_bytes.as_ref().len();
            bytes.extend_from_slice(&(state_bytes_len as u32).to_le_bytes());
            bytes.extend_from_slice(state_bytes.as_ref());
        }
        std::borrow::Cow::Owned(bytes)
    }

    fn into_bytes(self) -> Vec<u8> {
        let metadata_bytes = self.metadata.to_bytes();
        let metadata_bytes_len = metadata_bytes.as_ref().len();
        let mut bytes = vec![];
        bytes.extend_from_slice(&(metadata_bytes_len as u32).to_le_bytes());
        bytes.extend_from_slice(metadata_bytes.as_ref());
        bytes.extend_from_slice(&(self.states.len() as u32).to_le_bytes());
        for state in self.states.into_iter() {
            let state_bytes = state.to_bytes();
            let state_bytes_len = state_bytes.as_ref().len();
            bytes.extend_from_slice(&(state_bytes_len as u32).to_le_bytes());
            bytes.extend_from_slice(state_bytes.as_ref());
        }
        bytes
    }

    fn from_bytes(bytes: std::borrow::Cow<[u8]>) -> Self {
        let bytes = bytes.into_owned();
        let metadata_len = u32::from_le_bytes(bytes[0..4].try_into().unwrap()) as usize;
        let metadata_bytes = &bytes[4..4 + metadata_len];
        let metadata = Metadata::from_bytes(metadata_bytes.into());
        let mut states = Vec::new();
        let states_len = u32::from_le_bytes(
            bytes[4 + metadata_len..8 + metadata_len]
                .try_into()
                .unwrap(),
        ) as usize;
        let mut offset = 8 + metadata_len;
        for _ in 0..states_len {
            let state_len =
                u32::from_le_bytes(bytes[offset..offset + 4].try_into().unwrap()) as usize;
            offset += 4;
            let state_bytes = &bytes[offset..offset + state_len];
            offset += state_len;
            let state = S::from_bytes(state_bytes.into());
            states.push(state);
        }
        Self { metadata, states }
    }
}

impl<S> Pool<S> {
    /// Creates a new pool with the given metadata.
    pub fn new(metadata: Metadata) -> Self {
        Self {
            metadata,
            states: Vec::new(),
        }
    }

    /// Returns the metadata of the pool.
    pub fn metadata(&self) -> &Metadata {
        &self.metadata
    }

    /// pushes a new state into the pool.
    pub fn push(&mut self, state: S) {
        self.states.push(state);
    }

    /// Returns the states of the pool.
    pub fn states(&self) -> &Vec<S> {
        &self.states
    }

    /// Returns a mutable reference to the states of the pool.
    pub fn states_mut(&mut self) -> &mut Vec<S> {
        &mut self.states
    }
}

#[doc(hidden)]
pub trait ReePool<S> {
    fn get_pool_info(&self) -> PoolInfo;

    fn get_pool_basic(&self) -> PoolBasic;

    fn rollback(&mut self, txid: Txid) -> Result<(), String>;

    fn finalize(&mut self, txid: Txid) -> Result<(), String>;
}

#[doc(hidden)]
impl<S> ReePool<S> for Pool<S>
where
    S: Storable + StateView,
{
    fn get_pool_basic(&self) -> PoolBasic {
        PoolBasic {
            name: self.metadata.name.clone(),
            address: self.metadata.address.clone(),
        }
    }

    fn get_pool_info(&self) -> PoolInfo {
        let metadata: Metadata = self.metadata.clone();
        let Metadata {
            key,
            key_derivation_path,
            name,
            address,
        } = metadata;
        let state = self
            .states
            .last()
            .map(|s| s.inspect_state())
            .unwrap_or(StateInfo {
                txid: Txid::zero(),
                nonce: 0,
                coin_reserved: vec![],
                btc_reserved: 0,
                utxos: vec![],
                attributes: "{}".to_string(),
            });
        let StateInfo {
            txid: _,
            nonce,
            coin_reserved,
            btc_reserved,
            utxos,
            attributes,
        } = state;
        PoolInfo {
            key,
            key_derivation_path,
            name,
            address,
            nonce,
            coin_reserved,
            btc_reserved,
            utxos,
            attributes,
        }
    }

    fn rollback(&mut self, txid: Txid) -> Result<(), String> {
        let idx = self
            .states
            .iter()
            .position(|state| state.inspect_state().txid == txid)
            .ok_or("txid not found".to_string())?;
        if idx == 0 {
            self.states.clear();
            return Ok(());
        }
        self.states.truncate(idx);
        Ok(())
    }

    fn finalize(&mut self, txid: Txid) -> Result<(), String> {
        let idx = self
            .states
            .iter()
            .position(|state| state.inspect_state().txid == txid)
            .ok_or("txid not found".to_string())?;
        if idx == 0 {
            return Ok(());
        }
        self.states.rotate_left(idx);
        self.states.truncate(self.states.len() - idx);
        Ok(())
    }
}

/// The Pools trait defines the interface for the exchange pools, must be marked as `#[ree_exchange_sdk::pools]`.
pub trait Pools {
    /// The concrete type of the pool state.
    type State: Storable + StateView;

    /// The memory ID for the pool storage.
    const POOL_MEMORY: u8;

    /// The memory ID for the block storage.
    const BLOCK_MEMORY: u8;

    /// The memory ID for the transaction storage.
    const TRANSACTION_MEMORY: u8;

    /// useful for ensuring that the exchange is running on the correct network.
    fn network() -> Network;

    /// Returns the state finalize threshold, useful for determining when a transaction is considered finalized.
    fn finalize_threshold() -> u32 {
        32
    }
}

/// A set of hooks that can be implemented to respond to various events in the exchange lifecycle.
/// It must be implemented over the `Pools` type and marked as `#[ree_exchange_sdk::hook]`.
pub trait Hook {
    /// This function is called when a new block is received, before any processing.
    fn on_block_received(_args: NewBlockInfo) {}

    /// This function is called when a transaction is dropped from the mempool.
    fn on_state_reverted(_address: String, _txid: Txid) {}

    /// This function is called when a transaction is confirmed in a block.
    fn on_state_confirmed(_address: String, _txid: Txid, _block: Block) {}

    /// This function is called when a transaction reaches the finalize threshold.
    fn on_state_finalized(_address: String, _txid: Txid, _block: Block) {}

    /// This function is called after a new block is processed.
    fn on_block_processed(_args: NewBlockInfo) {}
}

/// A trait for accessing the pool storage.
/// The user-defined `Pools` type will automatically implement this trait.
pub trait PoolStorageAccess<P: Pools> {
    fn get(address: &String) -> Option<Pool<P::State>>;

    fn insert(pool: Pool<P::State>);

    fn remove(address: &String) -> Option<Pool<P::State>>;

    fn iter() -> iter::PoolIterator<P>;
}

#[doc(hidden)]
pub fn iterator<P>() -> iter::PoolIterator<P>
where
    P: Pools,
{
    let mm = MemoryManager::init(DefaultMemoryImpl::default());
    let vm = mm.get(MemoryId::new(P::POOL_MEMORY));
    iter::PoolIterator {
        inner: PoolStorage::<P::State>::init(vm),
        cursor: None,
    }
}

#[doc(hidden)]
pub mod iter {
    pub struct PoolIterator<P: super::Pools> {
        pub(crate) inner: super::PoolStorage<P::State>,
        pub(crate) cursor: Option<String>,
    }

    impl<P> std::iter::Iterator for PoolIterator<P>
    where
        P: super::Pools,
    {
        type Item = (String, super::Pool<P::State>);

        fn next(&mut self) -> Option<Self::Item> {
            match self.cursor {
                Some(ref cursor) => match self
                    .inner
                    .iter_from_prev_key(cursor)
                    .next()
                    .map(|e| e.into_pair())
                {
                    Some((k, v)) => {
                        self.cursor = Some(k.clone());
                        Some((k, v))
                    }
                    None => None,
                },
                None => match self.inner.iter().next().map(|e| e.into_pair()) {
                    Some((k, v)) => {
                        self.cursor = Some(k.clone());
                        Some((k, v))
                    }
                    None => None,
                },
            }
        }
    }
}
